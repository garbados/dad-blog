<!DOCTYPE html>
<html>
<head>
  <meta charset="utf-8">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <title>W O R D S</title>

  <link rel="stylesheet" href="static/style.css">
  <link rel="stylesheet" href="//cdnjs.cloudflare.com/ajax/libs/highlight.js/10.6.0/styles/default.min.css">
  <script src="//cdnjs.cloudflare.com/ajax/libs/highlight.js/10.6.0/highlight.min.js"></script>
  <script>hljs.highlightAll();</script>
</head>
<body>
  <section class="section">
    <div class="container">
      <div class="columns">
        <div class="column is-one-fifth">
          <p class="title"><a href="index.html">W O R D S</a></p>
          <p class="subtitle">Essays, etc.</p>
          <hr>
          <figure class="image" alt="A picture of me.">
            <img src="static/self.jpg">
          </figure>
          <p class="content">
            <p>My name is Diana. I make things but generally not very well. I put thoughts here.</p>
          </p>
          <hr>
          <aside class="menu">
            <p class="menu-label">Me, elsewhere:</p>
            <ul class="menu-list">
              <li>
                <a href="https://friend.camp/@garbados">Mastodon</a>
              </li>
              <li>
                <a href="https://github.com/garbados">GitHub</a>
              </li>
            </ul>
          </aside>
          <hr>
          <aside class="menu">
            <p class="menu-label">Meta</p>
            <ul class="menu-list">
              <li>
                <a href="rss.xml">RSS</a>
              </li>
            </ul>
          </aside>
        </div>
        <div class="column is-four-fifths">    <div class="box">
      <p>
        <a href="index.html"><i class="fa fa-home" aria-hidden="true"></i></a>
        &gt;
        <a href="veteran-pouchdb.html">A Veteran&#x27;s Guide to PouchDB</a>
      </p>
      <hr>
      <div class="content"><h1 id="a-veterans-guide-to-pouchdb">A Veteran&#39;s Guide to PouchDB</h1>
<p>I have written a great deal of software, from web applications to SaaS products (from inception to long-term maintenance) to a litany of database tools, and most of what I have to show for it is bitterness and trauma. I never want anyone to feel as lost and helpless and burnt out as I have; I would rather programmers feel the quiet dignity and insistent ethos of civil servants, because our works are so akin to public infrastructure. The discipline is <a href="https://garbados.github.io/my-blog/regarding-software.html">in a bad way</a> but it is still important to understand how to use the right tools for the right application. We owe that much to users, and to each other as craftspeople.</p>
<p>This guide is intended for people with moderate experience with JavaScript, as well as people who have worked with databases much at all, though I hope anyone intending to write software might find its architectural considerations useful.</p>
<p>Any application that needs to store and query data should rely on robust standards for doing so, and as a result I use <a href="https://pouchdb.com/">PouchDB</a> in most of my projects. PouchDB is a database that contains several adapters that allow it to store data in many possible backends, including <a href="https://couchdb.apache.org/">CouchDB</a>, LevelDB, IndexedDB, and LocalStorage; among the available options, PouchDB tries to choose the most appropriate one for its environment. PouchDB&#39;s semantics mirror CouchDB&#39;s, and it even supports CouchDB&#39;s replication protocol. This makes it trivial to instrument strong backups by replicating with a CouchDB cluster. As well, because PouchDB can run in browsers, you can replicate data down from server applications to user devices, creating a seamless experience in disconnected or low-connectivity circumstances. Applying this <a href="http://offlinefirst.org/">offline first</a> pattern is crucial for supporting users in remote and tenuous situations, and PouchDB makes it easy to do so.</p>
<p>PouchDB also has a thriving plugin ecosystem, allowing you to easily extend your database with new <a href="https://github.com/pouchdb-community/pouchdb-quick-search">query interfaces</a>, <a href="https://github.com/garbados/comdb">encryption</a>, and even <a href="https://github.com/RangerMauve/pouchdb-adapter-hyperbee">p2p storage adapters</a>. It is also very easy to write your own application-specific plugins, in order to contextualize your database interface to your requirements.</p>
<p>In this guide I&#39;ll discuss example apps modeling a blog and a social network, but the real strength of these patterns lies in the disaster response team of the future who deploys mapping drones that autonomously construct a geo-indexed map of the area in realtime. The drones replicate telemetry with homebase so responders can account for damage to roads and other infrastructure in their deployment of resources, but they replicate with each other too so that they know how to plot their movements over unexplored terrain. Simple replication makes these advanced usage scenarios significantly easier to build.</p>
<p>In this essay I will demonstrate some basic usage of PouchDB, and then discuss advanced patterns like using and writing plugins, subclassing PouchDB, and modeling your data for efficient queries. So, let&#39;s begin!</p>
<h2 id="installation-and-basic-usage">Installation and Basic Usage</h2>
<p>PouchDB is a JavaScript library that you can install using <a href="https://www.npmjs.com/">npm</a>:</p>
<pre><code class="language-bash">$ npm i -S pouchdb</code></pre>
<p>Once installed, you can <code>require()</code> PouchDB in your project:</p>
<pre><code class="language-javascript">const PouchDB = require(&#39;pouchdb&#39;)
const db = new PouchDB(&#39;test&#39;)
db.post({ hello: &#39;world&#39; }).then((result) =&gt; {
  console.log(result)
  // {
  // &quot;ok&quot;:true,
  // &quot;id&quot;:&quot;37b879902bdd9735382333d59a0018dd&quot;,
  // &quot;rev&quot;:&quot;1-15f65339921e497348be384867bb940f&quot;
  // }
  const { id } = result
  return db.get(id)
}).then((doc) =&gt; {
  console.log(doc)
  // { _id: &#39;...&#39;, _rev: &#39;1-...&#39;, hello: &#39;world&#39; }
})</code></pre>
<p>If you run this code in a server environment, PouchDB will create a folder called <code>test</code> where it stores the files for a <a href="https://github.com/google/leveldb">LevelDB</a> instance. You can also pass in the URL to a CouchDB database, and PouchDB will use its CouchDB adapter to use it as its data store. If you run this code in the browser, PouchDB will select an adapter that is best supported by that browser.</p>
<p>I like to use the environment variable <code>COUCH_URL</code> to store the URL of my CouchDB installation, so that I can use it to optionally hook my PouchDB instance up to it or to create a local database instead if <code>COUCH_URL</code> is not set:</p>
<pre><code class="language-javascript">const COUCH_URL = process.env.COUCH_URL
const DB_NAME = &#39;test&#39;
const DB_PATH = COUCH_URL
  ? `${COUCH_URL}/${DB_NAME}`
  : DB_NAME
const db = new PouchDB(DB_PATH)</code></pre>
<p>This is useful when you already have a database in CouchDB with lots of data, and you want to explore that data with the fallback of marshaling it yourself.</p>
<p>Now, for example&#39;s sake, let&#39;s consider an example application: a multi-user blog where documents in the database represent each user&#39;s individual posts. Let&#39;s see these documents using the <a href="https://pouchdb.com/api.html#batch_fetch">.allDocs()</a> method:</p>
<pre><code class="language-javascript">db.allDocs({ include_docs: true, limit: 1 })
  .then((result) =&gt; {
    console.log(result)
    // {
    //   total_rows: 10010,
    //   offset: 0
    //   rows: [{
    //     id: &#39;...&#39;,
    //     key: &#39;...&#39;,
    //     value: { rev: &#39;...&#39; },
    //     doc: {
    //       _id: &#39;entry:garbados:1234:5678&#39;,
    //       _rev: &#39;...&#39;,
    //       created_at: 1234,
    //       content: &#39;...&#39;,
    //       type: &#39;entry&#39;,
    //       user_id: &#39;user:garbados&#39;,
    //     }
    //   }]
    // }
  })</code></pre>
<p>The <code>.allDocs()</code> method sorts documents by their <code>_id</code> field, meaning that if you carefully construct an <code>_id</code> you can make this index instantly useful. In the above example, the document&#39;s <code>_id</code> field is namespaced to the document&#39;s type, its associated user, its creation date, as well as a random suffix to distinguish posts submitted simultaneously. Here is the code that I used to construct this dummy data:</p>
<pre><code class="language-javascript">// construct users
const users = []
for (let i = 0; i &lt; 10; i++) {
  const type = &#39;user&#39;
  const name = randomChars(10)
  const createdAt = Date.now()
  const id = `${type}:${name}`
  users.push({
    _id: id,
    createdAt,
    name
  })
}
// construct entries
const docs = []
for (let i = 0; i &lt; 10000; i++) {
  const type = &#39;entry&#39;
  const content = randomChars(10) // random entry text
  const user = pickRandom(users)
  const createdAt = Date.now()
  const suffix = Math.floor(createdAt * Math.random()) // random suffix
  const id = `${type}:${user.name}:${createdAt}:${suffix}`
  docs.push({
    _id: id,
    created_at: createdAt,
    content,
    type,
    user_id: user._id
  })
}
// insert the documents
db.bulkDocs([...users, ...docs])</code></pre>
<p>Because of how these IDs are constructed, you can use the <code>startkey</code> and <code>endkey</code> options to retrieve specific subsets of your data, such as all documents of a specific type, or all entries chronologically:</p>
<pre><code class="language-javascript">// get all users
db.allDocs({
  startkey: &#39;user&#39;,
  endkey: &#39;user:\ufff0&#39;,
  include_docs: true
}).then((result) =&gt; {
  // all users
  console.log(result)
})</code></pre>
<p>Because PouchDB sorts IDs alphabetically, we can use high-value unicode characters to define specific key ranges to return. I use the character <code>\ufff0</code> because it is the highest valid unicode character. Here we use it to return all entries by a specific user:</p>
<pre><code class="language-javascript">db.allDocs({
  startkey: &#39;entry:garbados&#39;,
  endkey: &#39;entry:garbados:\ufff0&#39;,
  include_docs: true
}).then((result) =&gt; {
  // all entries by garbados
  // oldest to latest
  console.log(result)
})</code></pre>
<p>Because the part of an entry&#39;s ID that follows the username is its creation date, the results from above are automatically sorted chronologically. By default, results are sorted in ascending order, but you can use the <code>descending</code> option to reverse this behavior:</p>
<pre><code class="language-javascript">db.allDocs({
  startkey: &#39;entry:garbados&#39;,
  endkey: &#39;entry:garbados:\ufff0&#39;,
  include_docs: true,
  descending: true
}).then((result) =&gt; {
  // all entries by garbados
  // latest to oldest
  console.log(result)
})</code></pre>
<p>Of course, you won&#39;t always be able to support all the queries an application needs through constraining document IDs, so let&#39;s talk about PouchDB&#39;s query interfaces.</p>
<h2 id="querying-with-pouchdb">Querying with PouchDB</h2>
<p>PouchDB mirrors the query semantics of CouchDB, and so exposes a map/reduce indexing system called &#39;views&#39;. The plugin <a href="https://github.com/pouchdb/pouchdb/tree/master/packages/node_modules/pouchdb-find">pouchdb-find</a> adds support for the <a href="https://docs.couchdb.org/en/stable/api/database/find.html">Mango</a> indexing and query system. Each have different abilities, so applications may find use for both. Let&#39;s begin with views.</p>
<p>Views are a part of <a href="https://docs.couchdb.org/en/stable/ddocs/views/intro.html">design documents</a>, which PouchDB and CouchDB use to define indexes. Here is an example design document for our blog application:</p>
<pre><code class="language-javascript">db.put({
  _id: &#39;_design/queries&#39;,
  views: {
    entriesByDate: {
      map: function (doc) {
        if (doc.type !== &#39;entry&#39;) { return }
        const date = new Date(doc.created_at)
        emit([
          date.getFullYear(),
          date.getMonth() + 1, // js 0-indexes months
          date.getDate(),
          date.getHours(),
          date.getMinutes(),
          date.getSeconds()
        ])
      }.toString(),
      reduce: &#39;_count&#39;
    }
  }
})</code></pre>
<p>Once the design document is in the database, we can use that <code>entriesByDate</code> view to query entries by when they were posted:</p>
<pre><code class="language-javascript">// get all posts by year-month
db.query(&#39;queries/entriesByDate&#39;, {
  group: true,
  group_level: 2
}).then((result) =&gt; {
  console.log(result.rows)
  // [ { key: [ 2021, 3 ], value: 10000 } ]
})</code></pre>
<p>Because the view specifies a &#39;reduce&#39; step, PouchDB will group results based on whether their keys match. So, the <code>value</code> property of the result means that 10000 documents had a key starting with <code>[2021, 3]</code> AKA March 2021.</p>
<p>We can also skip the reduce step to retrieve entries from a specific date range:</p>
<pre><code class="language-javascript">// get all posts from March 11 2021
db.query(&#39;queries/entriesByDate&#39;, {
  reduce: false,
  include_docs: true,
  startkey: [2021, 3, 11],
  endkey: [2021, 3, 11, &#39;\ufff0&#39;]
}).then((result) =&gt; {
  console.log(result)
  // { rows: [{ id: &#39;...&#39;, doc: { ... }, ... }, ...] }
})</code></pre>
<p>JavaScript views like this are best when you need a reduce step, or you need to transform the document in some way in order to emit the desired key. In the above example, we convert the <code>created_at</code> property from milliseconds since the UNIX epoch to a date and time array, and we use a reduce step to count entries according to the levels of this parsed date.</p>
<p>The alternative to JavaScript views is called Mango, and it does not allow you to transform documents or to use a reduce step. However, you do not need to write a map function to instrument a Mango query. Instead, you create an index, and then you query it using <a href="https://docs.couchdb.org/en/stable/api/database/find.html#selector-syntax">selectors</a>. Selectors can be very sophisticated, allowing for complex queries that would be difficult to instrument in a JavaScript view.</p>
<p>To use Mango with PouchDB, you will need the <a href="https://github.com/pouchdb/pouchdb/tree/master/packages/node_modules/pouchdb-find">pouchdb-find</a> plugin. Then you can attach it to PouchDB like this:</p>
<pre><code class="language-javascript">const PouchDB = require(&#39;pouchdb&#39;)
PouchDB.plugin(require(&#39;pouchdb-find&#39;))</code></pre>
<p>Now you can use the <code>.createIndex()</code> method to create Mango indices, and <code>.find()</code> to perform Mango queries. We&#39;ll talk more about PouchDB plugins later.</p>
<p>You can apply Mango selectors both at indexing time and query time. Applying a selector at indexing time allows you to use complex operators like <code>$regex</code> efficiently, because they are calculated before query time. For example, consider an index that maintains a list of all entries that contain the consecutive characters &quot;abc&quot;. Here is how to write that index:</p>
<pre><code class="language-javascript">db.createIndex({
  index: {
    partial_filter_selector: {
      type: &#39;entry&#39;,
      content: { $regex: &#39;abc&#39; }
    },
    fields: [&#39;user_id&#39;]
  },
  ddoc: &#39;mango&#39;,
  name: &#39;abc&#39;
})</code></pre>
<p>This creates a design document called <code>_design/mango</code> with a view called <code>abc</code>. We can invoke this index like this:</p>
<pre><code class="language-javascript">db.find({
  selector: { user_id: &#39;garbados&#39; },
  use_index: [&#39;_design/mango&#39;, &#39;abc&#39;]
}).then((result) =&gt; {
  console.log(result)
  // {
  //   docs: [
  //     {
  //       _id: &#39;entry:garbados:1234:5678&#39;,
  //       _rev: &#39;1-...&#39;,
  //       created_at: 1615494046689,
  //       content: &#39;eabcoxjlyh&#39;,
  //       type: &#39;entry&#39;,
  //       user_id: &#39;user:garbados&#39;
  //     }
  //   ],
  //   bookmark: &#39;...&#39;
  // }
})</code></pre>
<p>Mango queries by default return whole documents, as though you were using <code>include_docs: true</code>. You can constrain the fields that the query returns using the <code>fields</code> option:</p>
<pre><code class="language-javascript">db.find({
  selector: { user_id: &#39;garbados&#39; },
  fields: [&#39;_id&#39;, &#39;user_id&#39;, &#39;created_at&#39;]
  use_index: [&#39;_design/mango&#39;, &#39;abc&#39;]
}).then((result) =&gt; {
  console.log(result)
  // {
  //   docs: [
  //     {
  //       _id: &#39;entry:garbados:1234:5678&#39;,
  //       created_at: 1615494046689,
  //       user_id: &#39;user:garbados&#39;
  //     }
  //   ],
  //   bookmark: &#39;...&#39;
  // }
})</code></pre>
<p>Mango indices are best for when you want to instrument complex queries without writing a JavaScript view. By using objects rather than functions, Mango indices and queries are easier to construct, constrain, and maintain than JavaScript views. Moreover, when using CouchDB, Mango queries return faster because they do not need to invoke a JavaScript interpreter.</p>
<h2 id="plugins">Plugins</h2>
<p>As you saw with <code>pouchdb-find</code>, you can extend the capabilities of PouchDB using <a href="https://pouchdb.com/api.html#plugins">plugins</a>. Plugins mutate PouchDB by adding or overriding methods, and you can use as many as you like. You can even write your own very simply.</p>
<p>A plugin I include in almost all my projects applies the <code>forcePut</code> method, which forcibly updates a document. PouchDB uses a revision system to support CouchDB replication, and as a result document updates must have a correct <code>_rev</code> value in order to update a document. But in practice, especially when working with design documents, it pays to be able to update a document without knowing anything about its prior revision.</p>
<p>Here is the plugin:</p>
<pre><code class="language-javascript">PouchDB.plugin({
  forcePut: async function (doc) {
    try {
      // separate old doc from _rev
      const { _rev, ...oldDoc } = await this.get(doc._id)
      // cheap deep comparison of old and new
      const json1 = JSON.stringify(doc)
      const json2 = JSON.stringify(oldDoc)
      // only do update if they differ
      if (json1 !== json2) {
        return this.put({ _rev, ...doc })
      } else {
        return Promise.resolve()
      }
    } catch (err) {
      if (err.status === 404) {
        // no prior version exists
        return this.put(doc)
      } else {
        throw err
      }
    }
  }
})</code></pre>
<p>Now you can use the <code>.forcePut()</code> method on PouchDB instances:</p>
<pre><code class="language-javascript">const DDOC = {
  _id: &#39;_design/queries&#39;,
  views: { ... }
}
db.forcePut(DDOC)</code></pre>
<p>This is useful during database setup, so that you can ensure all your design documents are up to date.</p>
<p>Another plugin I commonly use adds the <code>.forceRemove</code> method, which deletes a document without requiring anything more than its ID:</p>
<pre><code class="language-javascript">PouchDB.plugin({
  forceRemove: async function (docOrDocId, ...opts) {
    // .remove() supports accepting a doc or doc ID, so this does too
    const id = typeof docOrDocId === &#39;string&#39; ? docOrDocId : docOrDocId._id
    // get the rev of a document if it already exists
    const rev = await this.get(id).catch((err) =&gt; {
      if (err.status === 404) {
        return {}
      } else {
        throw err
      }
    }).then((doc) =&gt; {
      return doc._rev
    })
    // do nothing if the doc doesn&#39;t already exist / has already been deleted
    if (rev) {
      return this.remove({ _id: id, _rev: rev }, ...opts)
    }
  }
})</code></pre>
<p>The real power of plugins lies in being able to compose different features together, giving your database superpowers independent of the underlying storage mechanism. For example, consider this snippet that applies a series of plugins:</p>
<pre><code class="language-javascript">const PouchDB = require(&#39;pouchdb&#39;)
PouchDB.plugin(require(&#39;comdb&#39;))
PouchDB.plugin(require(&#39;pouchdb-adapter-memory&#39;))
PouchDB.plugin(require(&#39;pouchdb-find&#39;))
PouchDB.plugin(require(&#39;pouchdb-quick-search&#39;))</code></pre>
<p>These plugins add a variety of new abilities to your PouchDB instance, including the <code>.createIndex()</code> and <code>.find()</code> methods, but also wraps existing methods like <code>.bulkDocs()</code> to provide transparent document encryption. In particular, let&#39;s talk about what <code>pouchdb-quick-search</code> makes possible. It allows you to make queries looking for specific tokens in a field, such as words in entry contents. For example, the Mango view from above can be made more flexible and efficient using <code>.search()</code>:</p>
<pre><code class="language-javascript">db.search({
  query: &#39;abc&#39;,
  fields: [&#39;content&#39;],
  include_docs: true
}).then((result) =&gt; {
  console.log(result)
  // { rows: [...] }
})</code></pre>
<p>This returns all documents that contain the token &#39;abc&#39;, matching &#39;abc def&#39; but not &#39;abcdef&#39;. Unlike with the Mango index, where we had to apply a token selector at indexing time to properly filter results, now we can efficiently query for a specific token without instrumenting an index per token. The plugin takes care of indexing for us.</p>
<p>Unfortunately, plugins like <code>pouchdb-quick-search</code> do not function with some adapters, namely CouchDB. The CouchDB adapter can only utilize features that CouchDB already supports, while this plugin uses a search engine that CouchDB does not. As a result, to use this plugin while working with a CouchDB database, you must replicate data from CouchDB to the local database, like this:</p>
<pre><code class="language-javascript">const db = new PouchDB(&#39;test&#39;)
const remote = new PouchDB(`${COUCH_URL}/test`)
// begin replication, and then continue replicating
// to stay up to date with CouchDB
const replication = db.replicate.from(remote, {
  live: true,
  retry: true
})
Promise.resolve().then(async () =&gt; {
  // wait 3s to let the local catch up to the remote
  await new Promise((resolve) =&gt; {
    setTimeout(resolve, 3000)
  })
  // now search!
  const result = await db.search({
    query: &#39;abc&#39;,
    fields: [&#39;content&#39;]
  })
  console.log(result)
  // { rows: [...] }
})</code></pre>
<p><a href="https://github.com/garbados/comdb">ComDB</a>, another one of the plugins included above, overrides document updates and replication to encrypt documents. Let&#39;s see how that works:</p>
<pre><code class="language-javascript">const PASSWORD = &#39;goodpassword&#39;
const db = new PouchDB(&#39;test&#39;)
const db2 = new PouchDB(&#39;test-2&#39;)
const REMOTE_URL = `${COUCH_URL}/test-crypto`
// set a password. databases that use the same password and crypto options
// can decrypt each other&#39;s docs.
db.setPassword(PASSWORD, { name: REMOTE_URL })
db2.setPassword(PASSWORD)

// backup encrypted data to couchdb
db.replicate.to(REMOTE_URL).then(async () =&gt; {
  const result1 = await db.allDocs()
  // now let&#39;s destroy the unencrypted copy
  await db.destroy({ unencrypted_only: true })
  // so we can try restoring from the encrypted backup
  await PouchDB.replicate(REMOTE_URL, db2)
  // ensure everything was replicated ok
  const result2 = await db2.allDocs()
  console.log(result1.total_rows === result2.total_rows)
  // true
})</code></pre>
<p>Now that we have all these pieces in play, let me illustrate for you a usage scenario. Imagine a P2P social network called Chitter. Using ComDB and replication, user content remains encrypted on the client&#39;s disk as well as on Chitter servers. The only place unencrypted documents live is in RAM, so only encrypted data persists between restarts. User content flows up to Chitter servers,
and back out to user devices, but only users that have a document&#39;s associated decryption key can read it. A clever server would enforce document permissions itself; we&#39;ll talk about how to do that later. First, how do you do E2E encryption with ComDB? With <a href="https://www.npmjs.com/package/pouchdb-adapter-memory">pouchdb-adapter-memory</a>, which can make a PouchDB instance store its documents in memory rather than on disk:</p>
<pre><code class="language-javascript">const REMOTE_URL = `${process.env.COUCH_URL}/test-remote-encrypted`
// setup db: in-memory unencrypted, encrypted on disk
const db = new PouchDB(&#39;test-unencrypted&#39;, { adapter: &#39;memory&#39; })
db.setPassword(PASSWORD, { name: &#39;test-local-encrypted&#39; })
// continuously sync encrypted local with encrypted remote
const replication = PouchDB.sync(db, REMOTE_URL, { live: true, retry: true })
// write a document to memory
db.post({ hello: &#39;world&#39; }).then(async () =&gt; {
  // now it&#39;s on the encrypted local and the encrypted remote
  // but because it&#39;s unencrypted in local memory, you can query it normally
  const result = await db.search({
    query: &#39;world&#39;,
    fields: [&#39;hello&#39;]
  })
  console.log(result)
  // { rows: [{ _id: &#39;...&#39;, score: 1 }], &quot;total_rows&quot;: 1}
})</code></pre>
<p>We&#39;ll continue to develop Chitter as this guide progresses. For now it&#39;s sufficient to have demonstrated the power of composing plugins to instrument nontrivial features like E2E encryption and offline functionality.</p>
<h2 id="subclassing-for-context">Subclassing for Context</h2>
<p>Plugins modify PouchDB itself, causing their changes to affect all instances of PouchDB. In application development, your context of your data will shape the access patterns that you use and develop. Deciding how to organize these access patterns can have a huge impact on maintenance effort and onboarding time. I strongly recommend organizing access methods for your data around a subclass of PouchDB, and for different contexts, using multiple subclasses. Let&#39;s see this in the context of Chitter, which adds methods for working with different document types:</p>
<pre><code class="language-javascript">class ChitterDB extends PouchDB {
  // override fetch to add authentication headers when the user is set
  static fetch (url, opts) {
    if (this.userId) {
      opts.headers.set(&#39;X-Chitter-User-Id&#39;, this.userId)
      opts.headers.set(&#39;X-Chitter-Client-Key&#39;, this.clientKey)
    }
    return super.fetch(url, opts)
  }

  // setup required indices. run at app start
  async setup () {
    return Promise.all([
      // index followings
      this.createIndex({
        index: {
          partial_filter_selector: { type: &#39;follow&#39; },
          fields: [&#39;type&#39;, &#39;following&#39;]
        }
      }),
      // index followers
      this.createIndex({
        index: {
          partial_filter_selector: { type: &#39;follow&#39; },
          fields: [&#39;type&#39;, &#39;follower&#39;]
        }
      })
      // js views
      this.forcePut({
        _id: &#39;_design/queries&#39;,
        views: {
          // group all known tags and scope by date elements
          tags: {
            map: function (doc) {
              if (doc.type !== &#39;status&#39;) { return }
              for (let tag of doc.tags) {
                const date = new Date(doc.created_at)
                emit([
                  tag,
                  date.getFullYear(),
                  date.getMonth() + 1, // js 0-indexes months
                  date.getDate(),
                  date.getHours(),
                  date.getMinutes(),
                  date.getSeconds()
                ])
              }
            }.toString(),
            reduce: &#39;_count&#39;
          },
          // group tags by user ID
          tagsByUser: {
            map: function (doc) {
              if (doc.type !== &#39;status&#39;) { return }
              for (let tag of doc.tags) {
                const date = new Date(doc.created_at)
                emit([
                  doc.userId,
                  tag,
                  date.getFullYear(),
                  date.getMonth() + 1, // js 0-indexes months
                  date.getDate(),
                  date.getHours(),
                  date.getMinutes(),
                  date.getSeconds()
                ])
              }
            }.toString(),
            reduce: &#39;_count&#39;
          },
        }
      })      
    ])
  }

  // set the current user. call this when the user logs in
  setUser (userId, clientKey) {
    this.userId = userId
    this.clientKey = clientKey
  }

  // modify new statuses to set common fields
  async addStatus (content, doc = {}) {
    doc.type = &#39;status&#39;
    doc.createdAt = Date.now()
    doc.updatedAt = []
    doc.userId = self.userId || &#39;anonymous&#39; // annotate anonymous access
    if (!doc.access) { doc.access = &#39;public&#39; } // set default access rights
    const suffix = Math.floor(doc.createdAt * Math.random()) // cheap random int
    // create ID to support uniqueness and useful sorting
    doc._id = `${doc.type}:${doc.userId}:${doc.createdAt}:${suffix}`
    doc.content = content
    return this.put(doc)
  }

  // mark when a status was edited
  async editStatus (content, docId) {
    const doc = await this.get(docId)
    doc.updatedAt.push(Date.now())
    doc.content = content
    return this.put(doc)
  }

  // list statuses for a specific user, sorted chronologically
  async listStatuses (userId, opts = {}) {
    return this.allDocs({
      startkey: `status:${userId}`,
      endkey: `status:${userId}:\ufff0`,
      ...opts
    })
  }

  // search statuses by their content
  async searchStatuses (query) {
    const opts = { query, fields: [&#39;content&#39;], include_docs: true }
    return db.search(opts)
  }

  // set elements of a user profile, including display name, etc
  async setProfile (opts) {
    const type = &#39;profile&#39;
    const id = `${type}:${this.userId}`
    const doc = await this.get(id).catch((error) =&gt; {
      if (err.status === 404) {
        return { type, userId: this.userId, _id: id }
      } else {
        throw error
      }
    })
    const {
      name,
      displayName,
      description,
      avatarUrl,
      coverUrl
    } = opts
    if (name) doc.name = name
    if (displayName) doc.displayName = displayName
    if (description) doc.description = description
    if (avatarUrl) doc.avatarUrl = avatarUrl
    if (coverUrl) doc.coverUrl = coverUrl
    return this.put(doc)
  }

  async addProfileLink (key, value, url) {
    // ex: &quot;Pronouns: [she/her](https://http://pronoun.is/she/her)&quot;
    const suffix = Math.floor(Date.now() * Math.random())
    const doc = { key, value, url }
    doc.createdAt = Date.now()
    doc.type = &#39;profile-link&#39;
    const suffix = Math.floor(doc.createdAt * Math.random()) // cheap random int
    doc.userId = this.userId
    doc.profileId = `profile:${this.userId}`
    doc._id = `${doc.type}:${doc.userId}:${doc.suffix}`
    return this.put(doc)
  }

  async followUser (userId) {
    const type = &#39;follow&#39;
    const id = `${type}:${this.userId}:${userId}`
    const doc = {
      _id: id,
      type,
      createdAt: Date.now(),
      following: userId,
      follower: this.userId
    }
    return this.put(doc)
  }

  async unfollowUser (userId) {
    return this.forceRemove(`follow:${this.userId}:${userId}`)
  }

  async listFollowing () {
    return db.find({
      selector: { follower: this.userId }
    })
  }

  async listFollowers () {
    return db.find({
      selector: { following: this.userId }
    })
  }

  // set specific config values, like user UI preferences
  async setConfig (key, value) {
    const type = &#39;config&#39;
    const id = `${type}:${key}`
    const doc = await this.get(id).catch((err) =&gt; {
      if (err.status === 404) {
        // create origin doc if no prior exists
        return { _id: id, type, value }
      } else {
        throw err
      }
    })
    if (doc.value !== value) {
      doc.value = value
      return this.put(doc)
    }
  }

  // retrieve a config value, dropping the rest of the document
  async getConfig (key) {
    const doc = await this.get(`config:${key}`)
    return doc.value
  }
}</code></pre>
<p>In the above example, we extend PouchDB with methods like <code>.addStatus()</code> that are specific to the semantics of our application. By doing this, we can rely on existing methods like <code>.get()</code> and <code>.remove()</code>, while providing more tightly scoped methods that account for the usage context, such as <code>.getConfig()</code>, <code>.listFollowing()</code>, and <code>.followUser()</code>. Let&#39;s see what it&#39;s like to work with a status in this architecture:</p>
<pre><code class="language-javascript">const chitter = new ChitterDB(&#39;test&#39;)
chitter.addStatus(&#39;hello world&#39;).then(async ({ id }) =&gt; {
  // grab the ID from the underlying call to `.put()` and use `.get()` to retrieve the doc.
  const status = await chitter.get(id)
  console.log(status)
  // { _id: &#39;status:anonymous:1234:5678&#39;, createdAt: 1234, content: &#39;hello world&#39;, ... }
  // now edit the document, using only its id
  await chitter.editStatus(&#39;hello galaxy&#39;, id)
  const status2 = await chitter.get(id)
  console.log(status2.content)
  // hello galaxy
  // now we can remove it too
  await chitter.remove(status2)
})</code></pre>
<p>We can use PouchDB methods alongside our custom methods, to facilitate semantics like writing a status with only a string, or to standardize common queries.</p>
<p>If you need a second database, for example if you wanted to keep config settings and statuses in separate databases, you can create another subclass to encompass that additional scope:</p>
<pre><code class="language-javascript">class ChitterConfig extends PouchDB {
  // set specific config values, like user UI preferences
  async setConfig (key, value) {
    ...
  }

  // retrieve a config value, dropping the rest of the document
  async getConfig (key) {
    ...
  }
}</code></pre>
<p>By scoping methods in this way, it becomes easy to add new scopes without creating a monolithic interface. Furthermore, by maintaining multiple databases you can set different replication settings for them. For example, say you wanted to replicate statuses but not config values:</p>
<pre><code class="language-javascript">// local config: application settings, security keys
// not for replicating
const config = new ChitterConfig(&#39;config&#39;)
// statuses, to be replicated in order to be shared
const statuses = new ChitterStatuses(&#39;statuses&#39;)
const replication = statuses.replicate.to(REMOTE_URL, { live: true, retry: true })</code></pre>
<p>Next, let&#39;s talk about how to model your application&#39;s data in order to facilitate efficient queries. This is crucial for making your application snappy as well as maintainable.</p>
<h2 id="data-modeling-aka-how-to-decompose">Data Modeling AKA How To Decompose</h2>
<p>It is often tempting to imagine you will maintain only a few types of documents, and contain everything your application needs within them. For example, you might have a status document, which contains a user&#39;s account info as well as a list of tags and media URLs. Or you might have a forum thread, and each reply is contained within its parent status document. The trouble with this architecture is that documents which belong to many sources, such as a forum thread that many users will write to, are prone to generating conflicts and the experience of data loss.</p>
<p>In CouchDB and PouchDB the atomic unit is the document. That is, the canonical source of truth for a datapoint is the document that contains it. Whenever you update a document, you must provide a revision value, to prove to the database which version you want to update. If you try to update a version before the latest one, the database will generate a &quot;conflict&quot; that will not appear to users or be indexed by any view. Essentially, to the user, their write appears to have succeeded even as it effectively vanished. These conflicts can clutter a database, reducing performance and creating considerable resource requirements. So, it is crucial to architect against them.</p>
<p>As a rule, each document should only have one writer. Perhaps this means a user account, but what if the user has multiple devices? That can cause conflicts too. So you should scope documents to the most basic agent that writes data. In this case, the device itself. You can then aggregate data using replication, for example to sync data across a user&#39;s devices.</p>
<p>To continue with Chitter as an example, let&#39;s look at the various types a social media network might need. Each of these would be represented as a document type, and each instance of each type would be a single document:</p>
<ul>
<li>Statuses: Posts by user devices. Links to the posting user. Other devices may issue updates that must be aggregated into a status using views.</li>
<li>Status Media: A link to a media attachment. Includes metadata info as well as a link to the associated status. (Note: Although PouchDB and CouchDB support handling attachments, I <em>highly</em> recommend using a blob-specific store for storing files, such as S3-likes. These systems are simply not built for blob storage.)</li>
<li>Follows: Relations between users. Links to all associated users.</li>
<li>Profiles: A user&#39;s self-defined metadata. Links to the user.</li>
<li>Profile links: Links to external websites to be listed on the user&#39;s profile. Links to the user&#39;s profile.</li>
<li>Moderation Actions: Blocks, mutes, and other moderation actions should be stored individually, with an ID like <code>moderation:${actingUser}:${deviceId}:${targetUser}:${action}</code> in order to scope actions to devices. You can then use views to aggregate the moderation rules pertaining to specific users. (In addition, moderation actions can easily be shared in this model.)</li>
<li>Configuration: Config settings are stored individually, local to each user, and are not intended to be replicated.</li>
</ul>
<p>(You may notice this architecture differs from the above example <code>Chitter</code> class. The architecture will continue to evolve a bit as we learn more about using PouchDB. Consider these snippets as demonstrations more than production code.)</p>
<p>As an example of using this architecture, let&#39;s aggregate a status with multiple edits as well as associated media files:</p>
<pre><code class="language-javascript">class ChitterStatuses extends PouchDB {
  // setup indices. run at startup
  async setup () {
    return Promise.all([
      this.forcePut({
        _id: &#39;_design/queries&#39;,
        views: {
          &#39;status-edits&#39;: {
            map: function (doc) {
              if (doc.type !== &#39;status&#39;) { return }
              // doc._id of original: status:${userId}:${deviceId}:${createdAt}:${suffix}
              // of edit: ${originalId}:edit:${deviceId2}:${updatedAt}:${suffix2}
              emit([doc.original_id || doc._id, doc.updatedAt || doc.createdAt])
            }
          },
          &#39;status-media&#39;: {
            if (doc.type !== &#39;media&#39;) { return }
            emit(doc.status_id)
          }
        }
      })
    ])
  }

  async getStatus (id) {
    const { rows: edits } = await this.query(&#39;queries/status-edits&#39;, {
      startkey: [id],
      endkey: [id, &#39;\ufff0&#39;],
      descending: true
    })
    const ids = edits.map(({ id }) =&gt; { return id })
    const latest = await this.get(edits[0].id)
    const { rows } = await this.query(&#39;queries/status-media&#39;, {
      keys: ids,
      include_docs: true
    })
    const media = rows.map(row =&gt; row.doc)
    return { ...latest, media }
  }

  async getStatusEdits (id) {
    const { rows } = await this.query(&#39;queries/status-edits&#39;, {
      startkey: [id],
      endkey: [id, &#39;\ufff0&#39;],
      descending: true,
      including_docs: true
    })
    return rows.map(row =&gt; row.doc)
  }
}</code></pre>
<p>This method makes three requests to get the latest version of the status, as well as any associated media. By deleting media documents, they can be removed from being associated with a given status. This ensures conflicts will not appear even as a user writes and updates statuses from multiple devices. You can then use <code>.getStatusEdits()</code> to show users the edit history of a given status.</p>
<p>In complex replication scenarios, it can take an indeterminate period for data to spread through the network. As a result, your queries may return stale data as updates move from device to server to device, or by other transmission method such as shared P2P datastructures. It is important to consider this latency in the design of your application, such as by refreshing objects in the UI regularly. This ensures a seamless experience in the face of diminished connectivity as well as frequent incoming updates.</p>
<h2 id="conclusion">Conclusion</h2>
<p>This is only the tip of the iceberg on the capabilities of using PouchDB and its plugin ecosystem, as well as using CouchDB for user authentication. In future tutorials I&#39;ll discuss other advanced patterns and develop even stranger applications in more detail. Who knows, maybe you&#39;ll see a full Chitter demo!</p>
<p>PouchDB and CouchDB have become somewhat obscure and even venerable, but their core strengths remain profoundly relevant to modern software, especially to the principles of free and open software. PouchDB makes it easy to produce software where a user&#39;s data truly belongs to them, only passes over the network in protected forms, and does not rely on central servers. And because it works on servers and in browsers, you can use it throughout your stack.</p>
<p>Thanks for reading. I&#39;ll see you next time :)</p></div>
      <hr>
      <p><small><em>March 14, 2021</em></small></p>
    </div>
</div>
      </div>
    </div>
  </section>
</body>
</html>
